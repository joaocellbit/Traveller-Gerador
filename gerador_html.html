<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <title>Geração de Sistemas – Estrelas, Planetas e Planetoid Belts</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      margin: 20px;
    }
    h1, h2, h3 {
      color: #333;
    }
    table {
      border-collapse: collapse;
      margin-bottom: 20px;
      width: 100%;
      background: #fff;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th, td {
      padding: 5px;
      text-align: center;
    }
    th {
      background: #ddd;
    }
    .system {
      margin-bottom: 40px;
      padding: 10px;
      background: #e8e8e8;
      border: 1px solid #ccc;
    }
    input, button {
      padding: 5px;
      margin: 5px;
    }
    .mainworld {
      background-color: #ccffcc;
    }
  </style>
</head>
<body>
  <h1>Geração de Sistemas – Estrelas, Planetas e Planetoid Belts</h1>
  <p>
    Este exemplo integra as regras de criação de estrelas (com subtipo, conforme o World Builder’s Handbook), a geração de planetas e, agora, a inclusão de planetoid belts. Os belts são determinados pela rolagem 2D (resultado ≥ 8 indica belt) e, se presentes, a quantidade é definida através de uma rolagem 2D+DM (DM+1 se houver gas giants e +1 se houver estrelas secundárias). Os belts aparecem na tabela como um tipo especial ("Planetoid Belt").
  </p>
  <label for="numSystems">Número de sistemas:</label>
  <input type="number" id="numSystems" value="1" min="1">
  <button onclick="generateAndDisplay()">Gerar</button>

  <div id="output"></div>

  <script>
    // ----------------------------------------------------
    // FUNÇÕES AUXILIARES
    // ----------------------------------------------------
    function rollDice(n, faces) {
      let total = 0;
      for (let i = 0; i < n; i++) {
        total += Math.floor(Math.random() * faces) + 1;
      }
      return total;
    }

    function calcHabZone(lum) {
      if (lum <= 0) return "N/A";
      let innerHZ = Math.sqrt(lum / 1.51);
      let outerHZ = Math.sqrt(lum / 0.54);
      return `${innerHZ.toFixed(2)} - ${outerHZ.toFixed(2)} AU`;
    }

    function getOrbitMultiplier() {
      let r = rollDice(2, 6);
      const mapping = {2: 1.2, 3: 1.3, 4: 1.4, 5: 1.5, 6: 1.6, 7: 1.7, 8: 1.8, 9: 1.9, 10: 2.0, 11: 2.1, 12: 2.2};
      return mapping[r];
    }

    function generateAxialTilt() {
      let roll = rollDice(2, 6);
      let tilt = 0;
      if (roll >= 2 && roll <= 4) {
        let oneDie = rollDice(1, 6);
        tilt = (oneDie - 1) / 50;
      } else if (roll === 5) {
        let oneDie = rollDice(1, 6);
        tilt = oneDie / 5;
      } else if (roll === 6) {
        tilt = rollDice(1, 6);
      } else if (roll === 7) {
        tilt = 6 + rollDice(1, 6);
      } else if (roll === 8 || roll === 9) {
        tilt = 5 + rollDice(1, 6) * 5;
      } else {
        let extremeRoll = rollDice(1, 6);
        if (extremeRoll <= 2) {
          tilt = 10 + rollDice(1, 6) * 10;
        } else if (extremeRoll === 3) {
          tilt = 30 + rollDice(1, 6) * 10;
        } else if (extremeRoll === 4) {
          tilt = 90 + rollDice(1, 6);
        } else if (extremeRoll === 5) {
          tilt = 180 - rollDice(1, 6);
        } else {
          tilt = 120 + rollDice(1, 6) * 10;
        }
      }
      return tilt;
    }

    // ----------------------------------------------------
    // FUNÇÃO DE SUBTIPO (Numeric vs. M-type)
    // ----------------------------------------------------
    function determineSubtype(starType, isPrimary) {
      const validTypes = ["O","B","A","F","G","K","M"];
      if (!validTypes.includes(starType)) return "";
      const mappingNumeric = {
        2: 0, 3: 1, 4: 3, 5: 5, 6: 7, 7: 9, 8: 8, 9: 6, 10: 4, 11: 2, 12: 0
      };
      const mappingMTypePrimary = {
        2: 8, 3: 6, 4: 5, 5: 4, 6: 0, 7: 2, 8: 1, 9: 3, 10: 5, 11: 7, 12: 9
      };
      let r = rollDice(2,6);
      if (starType === "M" && isPrimary) {
        return mappingMTypePrimary[r] !== undefined ? mappingMTypePrimary[r] : 0;
      } else {
        return mappingNumeric[r] !== undefined ? mappingNumeric[r] : 0;
      }
    }

    // ----------------------------------------------------
    // TABELA PRIMARY STAR TYPES (simplificada)
    // ----------------------------------------------------
    function determinePrimaryStarTypeDM() {
      return 0;
    }

    function getTypeColumnResult(rollValue) {
      if (rollValue <= 2) return "Special";
      else if (rollValue === 3) return "M";
      else if (rollValue === 4) return "M";
      else if (rollValue === 5) return "M";
      else if (rollValue === 6) return "M";
      else if (rollValue === 7) return "K";
      else if (rollValue === 8) return "K";
      else if (rollValue === 9) return "G";
      else if (rollValue === 10) return "G";
      else if (rollValue === 11) return "F";
      else return "Hot";
    }

    function getHotColumn() {
      let r = rollDice(2,6);
      if (r <= 4) return "A";
      else if (r <= 9) return "B";
      else return "O";
    }

    function getSpecialColumn() {
      let r = rollDice(2,6);
      if (r <= 3) return "Class VI";
      else if (r <= 5) return "BD"; 
      else if (r <= 7) return "D";  
      else return "Class VI"; 
    }

    // ----------------------------------------------------
    // CLASSE STAR – GERAÇÃO COMPLETA (incluindo subtipo)
    // ----------------------------------------------------
    class Star {
      constructor(nome = "Primária") {
        this.nome = nome;
        this.isPrimary = (nome === "Primária");

        this.initialRoll = rollDice(2,6) + determinePrimaryStarTypeDM();
        if (this.initialRoll < 2) this.initialRoll = 2;
        if (this.initialRoll > 12) this.initialRoll = 12;

        let typeResult = getTypeColumnResult(this.initialRoll);

        this.finalType = null;     
        this.luminosityClass = "V"; 
        this.specialCategory = ""; 
        this.subtype = "";

        if (typeResult === "Special") {
          let specialRes = getSpecialColumn();
          if (specialRes === "BD") {
            this.finalType = "Brown Dwarf";
            this.luminosityClass = "—";
            this.specialCategory = "Brown Dwarf";
          } else if (specialRes === "D") {
            this.finalType = "White Dwarf";
            this.luminosityClass = "D";
            this.specialCategory = "Post-Stellar";
          } else if (specialRes === "Class VI") {
            this.finalType = "K"; 
            this.luminosityClass = "VI";
          } else {
            this.finalType = "M";
            this.luminosityClass = "VI";
          }
        }
        else if (typeResult === "Hot") {
          let hotRes = getHotColumn();
          this.finalType = hotRes;
          this.luminosityClass = "V";
        }
        else if (["M","K","G","F"].includes(typeResult)) {
          this.finalType = typeResult;
          this.luminosityClass = "V";
        }
        else {
          this.finalType = "M";
        }

        const exoticTypes = ["Brown Dwarf","White Dwarf","Black Hole","Neutron Star","Pulsar","Anomaly"];
        if (!exoticTypes.includes(this.finalType)) {
          this.subtype = determineSubtype(this.finalType, this.isPrimary);
        }

        let mainSequenceProps = {
          'O': { mass: 90, temperature: 50000, diameter: 20 },
          'B': { mass: 18, temperature: 30000, diameter: 7 },
          'A': { mass: 2.2, temperature: 10000, diameter: 2.2 },
          'F': { mass: 1.5, temperature: 7500, diameter: 1.7 },
          'G': { mass: 1.1, temperature: 6000, diameter: 1.1 },
          'K': { mass: 0.8, temperature: 5200, diameter: 0.8 },
          'M': { mass: 0.5, temperature: 3700, diameter: 0.5 }
        };
        let giantProps = {
          'O': { mass: 60, temperature: 30000, diameter: 40 },
          'B': { mass: 25, temperature: 15000, diameter: 20 },
          'A': { mass: 10, temperature: 10000, diameter: 10 },
          'F': { mass: 4, temperature: 7000, diameter: 6 },
          'G': { mass: 2.4, temperature: 5500, diameter: 15 },
          'K': { mass: 1.5, temperature: 4500, diameter: 30 },
          'M': { mass: 0.7, temperature: 3500, diameter: 60 }
        };
        let brownDwarfProps = { mass: 0.07, temperature: 1000, diameter: 0.15 };
        let whiteDwarfProps = { mass: 0.6, temperature: 100000, diameter: 0.01 };

        let chosenProps = null;
        if (this.specialCategory === "Brown Dwarf") {
          chosenProps = brownDwarfProps;
        } else if (this.luminosityClass === "D") {
          chosenProps = whiteDwarfProps;
        } else if (["III","II","Ib","Ia","VI"].includes(this.luminosityClass)) {
          chosenProps = giantProps[this.finalType] || giantProps["M"];
        } else {
          chosenProps = mainSequenceProps[this.finalType] || mainSequenceProps["M"];
        }

        this.spectralType = this.finalType;
        this.mass = chosenProps.mass;
        this.temperature = chosenProps.temperature;
        this.diameter = chosenProps.diameter;
        this.luminosity = parseFloat((Math.pow(this.diameter, 2) * Math.pow(this.temperature / 5772, 4)).toFixed(3));
        this.jumpLimit = parseFloat((0.93 * this.mass).toFixed(2));
        this.lifetime = parseFloat((10 * Math.pow(this.mass, -2.5)).toFixed(2));

        const colorMapping = {
          'O': "Azul",
          'B': "Azul-Branco",
          'A': "Branco",
          'F': "Amarelo-Branco",
          'G': "Amarelo",
          'K': "Laranja",
          'M': "Vermelho",
          'Brown Dwarf': "Marrom-escuro",
          'White Dwarf': "Branco-azulado"
        };
        this.color = colorMapping[this.finalType] || "Desconhecido";
      }

      getHabZone() {
        if (this.luminosity <= 0) return "N/A";
        return calcHabZone(this.luminosity);
      }

      toTableRow() {
        let typePlusSubtype = this.spectralType;
        if (this.subtype !== "") {
          typePlusSubtype += this.subtype;
        }
        return `<tr>
          <td>${this.nome}</td>
          <td>${this.initialRoll}</td>
          <td>${typePlusSubtype}</td>
          <td>${this.luminosityClass}</td>
          <td>${this.mass.toFixed(3)}</td>
          <td>${this.temperature}</td>
          <td>${this.diameter.toFixed(3)}</td>
          <td>${this.luminosity}</td>
          <td>${this.jumpLimit}</td>
          <td>${this.lifetime}</td>
          <td>${this.color}</td>
          <td>${this.getHabZone()}</td>
        </tr>`;
      }
    }

    // ----------------------------------------------------
    // FUNÇÕES PARA PLANETAS E PLANETOID BELTS
    // ----------------------------------------------------
    function checkGasGiantExistenceAndQuantity(star, starCount) {
      let rollExist = rollDice(2, 6);
      if (rollExist < 2) return 0;
      let quantityDM = 0;
      if (star.luminosityClass === "V" && starCount === 1) quantityDM += 1;
      let rollQty = rollDice(2,6) + quantityDM;
      if (rollQty <= 2) return 1;
      if (rollQty <= 4) return 1;
      if (rollQty <= 6) return 2;
      if (rollQty <= 8) return 3;
      if (rollQty <= 11) return 4;
      if (rollQty === 12) return 5;
      return 6;
    }

    class OrbitSlot {
      constructor(index, distanceAU) {
        this.index = index;
        this.distanceAU = distanceAU;
        this.planetType = null;
      }
    }

    function generateOrbitSlots() {
      let orbitCount = rollDice(2,6) + 2;
      let slots = [];
      let baseOrbit = 0.2;
      let currentDist = baseOrbit;
      for (let i = 1; i <= orbitCount; i++) {
        slots.push(new OrbitSlot(i, currentDist));
        currentDist *= getOrbitMultiplier();
      }
      return slots;
    }

    function toHex(value) {
      const hexDigits = "0123456789ABCDEF";
      if (value < 0) value = 0;
      if (value > 15) value = 15;
      return hexDigits[value];
    }

    class Planet {
      constructor(index, planetType, orbitAU) {
        this.index = index;
        this.orbit = orbitAU;
        this.planetType = planetType;
        this.numMoons = Math.floor(Math.random() * 6);
        this.isMainworld = false;
        
        if (planetType === "Gas Giant") {
          this.size = Math.floor(Math.random() * 3) + 8;
          this.atmosphere = 0;
          this.hydrographics = 0;
          this.gravity = parseFloat((Math.random() * 2 + 1).toFixed(2));
          this.temperature = Math.floor(Math.random() * 151) + 50;
          this.mass = parseFloat((Math.random() * 200 + 100).toFixed(2));
        } else if (planetType === "Planetoid Belt") {
          // Propriedades especiais para belts
          this.size = 0;
          this.atmosphere = 0;
          this.hydrographics = 0;
          this.gravity = 0;
          this.temperature = 0;
          this.mass = 0;
        } else {
          // Terrestres
          this.size = Math.floor(Math.random() * 11);
          this.atmosphere = Math.floor(Math.random() * 16);
          this.hydrographics = Math.floor(Math.random() * 11);
          this.gravity = parseFloat((1 + (this.size - 5) * 0.1 + (Math.random() * 0.4 - 0.2)).toFixed(2));
          this.temperature = Math.floor(Math.random() * 251) + 100;
          this.mass = parseFloat((Math.random() * (10 - 0.1) + 0.1).toFixed(2));
        }

        this.dayLength = parseFloat((Math.random() * (72 - 10) + 10).toFixed(2));
        this.axialTilt = generateAxialTilt();
        this.orbitalPeriod = 0;

        if (planetType === "Terrestrial (Inhabited)") {
          this.population = Math.floor(Math.random() * 13);
          if (this.population === 0) this.population = 1;
          this.government = Math.floor(Math.random() * 11);
          this.lawLevel = Math.floor(Math.random() * 11);
          this.techLevel = Math.floor(Math.random() * 16);
          this.starport = ['A','B','C','D','E','X'][Math.floor(Math.random()*6)];
          this.culture = ['Tradicional','Progressista','Militarista','Comercial'][Math.floor(Math.random()*4)];
          this.economy = ['Agrícola','Industrial','Tecnológica','Mineradora'][Math.floor(Math.random()*4)];
        } else {
          this.population = 0;
          this.government = 0;
          this.lawLevel = 0;
          this.techLevel = 0;
          this.starport = "X";
          this.culture = "N/A";
          this.economy = "N/A";
        }

        if (planetType === "Gas Giant" || planetType === "Planetoid Belt") {
          this.biome = planetType;
        } else {
          if (this.atmosphere < 3) {
            this.biome = this.hydrographics < 3 ? "Deserto" : "Árido";
          } else if (this.atmosphere <= 7) {
            this.biome = this.hydrographics > 7 ? "Oceânico" : "Temperado";
          } else {
            this.biome = this.hydrographics < 4 ? "Tundra" : "Tropical";
          }
        }
      }

      generateUWP() {
        if (this.planetType === "Gas Giant" || this.planetType === "Planetoid Belt") {
          return this.planetType;
        } else if (this.planetType === "Terrestrial (Barren)") {
          return "Barren";
        } else if (this.planetType === "Terrestrial (Inhabited)") {
          return `${this.starport}${toHex(this.size)}${toHex(this.atmosphere)}${toHex(this.hydrographics)}${toHex(this.population)}${toHex(this.government)}${toHex(this.lawLevel)}-${this.techLevel.toString().padStart(2,'0')}`;
        } else {
          return "Desconhecido";
        }
      }

      toTableRow() {
        let rowClass = this.isMainworld ? 'mainworld' : '';
        return `<tr class="${rowClass}">
          <td>${this.index}</td>
          <td>${this.orbit.toFixed(2)}</td>
          <td>${this.numMoons}</td>
          <td>${this.planetType}</td>
          <td>${this.mass}</td>
          <td>${this.gravity}</td>
          <td>${this.dayLength}</td>
          <td>${this.axialTilt.toFixed(2)}</td>
          <td>${this.orbitalPeriod}</td>
          <td>${this.population}</td>
          <td>${this.government}</td>
          <td>${this.lawLevel}</td>
          <td>${this.techLevel}</td>
          <td>${this.generateUWP()}</td>
          <td>${this.culture}</td>
          <td>${this.economy}</td>
          <td>${this.biome}</td>
        </tr>`;
      }
    }

    // ----------------------------------------------------
    // FUNÇÃO PARA GERAR PLANETOID BELTS
    // ----------------------------------------------------
    // As regras: rola 2D; se resultado ≥ 8, belts existem.
    // Em caso afirmativo, rola 2D+DM para determinar quantidade:
    // • ≤ 6 → 1 belt; 7–11 → 2 belts; 12+ → 3 belts.
    // Modificadores: +1 se houver gas giants, +1 se houver estrela secundária.
    function generatePlanetoidBelts(system) {
      let rollForBelt = rollDice(2,6);
      if (rollForBelt < 8) return []; // Não há belts
      let DM = 0;
      let gasGiantCount = system.planets.filter(p => p.planetType === "Gas Giant").length;
      if (gasGiantCount > 0) DM += 1;
      if (system.secondaryStars.length >= 1) DM += 1;
      let beltRoll = rollDice(2,6) + DM;
      let beltCount;
      if (beltRoll <= 6) beltCount = 1;
      else if (beltRoll <= 11) beltCount = 2;
      else beltCount = 3;
      let belts = [];
      // Posiciona os belts logo após a órbita mais externa
      let maxOrbit = Math.max(...system.orbitSlots.map(s => s.distanceAU));
      for (let i = 0; i < beltCount; i++) {
        let belt = new Planet(system.planets.length + 1, "Planetoid Belt", 0);
        belt.size = 0;
        belt.atmosphere = 0;
        belt.hydrographics = 0;
        belt.gravity = 0;
        belt.temperature = 0;
        belt.mass = 0;
        belt.dayLength = 0;
        belt.axialTilt = 0;
        belt.orbitalPeriod = 0;
        belt.population = 0;
        belt.government = 0;
        belt.lawLevel = 0;
        belt.techLevel = 0;
        belt.starport = "X";
        belt.culture = "N/A";
        belt.economy = "N/A";
        belt.biome = "Planetoid Belt";
        belt.generateUWP = function() { return "Planetoid Belt"; };
        // Atribui órbita: posiciona cada belt em intervalos além do maior slot
        belt.orbit = maxOrbit + (i + 1) * (Math.random() * 0.5 + 0.5);
        belts.push(belt);
      }
      return belts;
    }

    // ----------------------------------------------------
    // CLASSE SOLARSYSTEM – INTEGRA ESTRELAS, PLANETAS E BELTS
    // ----------------------------------------------------
    class SolarSystem {
      constructor(index) {
        this.index = index;
        this.primaryStar = new Star("Primária");
        this.secondaryStars = [];
        if (Math.random() < 0.3) {
          this.secondaryStars.push(new Star("Secundária"));
        }
        let starCount = 1 + this.secondaryStars.length;
        let ggCount = checkGasGiantExistenceAndQuantity(this.primaryStar, starCount);
        this.orbitSlots = generateOrbitSlots();

        if (ggCount > 0) {
          let shuffled = [...this.orbitSlots].sort(() => Math.random() - 0.5);
          let ggSlots = shuffled.slice(0, ggCount);
          ggSlots.forEach(s => s.planetType = "Gas Giant");
        }

        this.planets = [];
        let planetIndex = 1;
        for (let slot of this.orbitSlots) {
          if (slot.planetType === "Gas Giant") {
            let pl = new Planet(planetIndex, "Gas Giant", slot.distanceAU);
            this.planets.push(pl);
            planetIndex++;
          } else {
            if (rollDice(1,6) >= 4) {
              let r = Math.floor(Math.random()*100) + 1;
              let pType = (r <= 60) ? "Terrestrial (Barren)" : "Terrestrial (Inhabited)";
              let pl = new Planet(planetIndex, pType, slot.distanceAU);
              this.planets.push(pl);
              planetIndex++;
            }
          }
        }

        // Adiciona planetoid belts
        let belts = generatePlanetoidBelts(this);
        belts.forEach(b => { this.planets.push(b); });

        // Calcula período orbital
        this.planets.forEach(p => {
          let periodYears = Math.sqrt(Math.pow(p.orbit,3) / this.primaryStar.mass);
          p.orbitalPeriod = Math.round(periodYears * 365.25);
        });

        // Determina mainworld
        let L = this.primaryStar.luminosity;
        let innerHZ = Math.sqrt(L / 1.51);
        let outerHZ = Math.sqrt(L / 0.54);
        let candidates = this.planets.filter(pp => pp.planetType === "Terrestrial (Inhabited)" && pp.orbit >= innerHZ && pp.orbit <= outerHZ);
        let mainPlanet = null;
        if (candidates.length > 0) {
          mainPlanet = candidates.reduce((best, current) => (current.population > best.population) ? current : best);
        } else {
          let terrestrial = this.planets.filter(pp => pp.planetType.startsWith("Terrestrial"));
          if (terrestrial.length > 0) {
            mainPlanet = terrestrial.reduce((best, current) => (current.population > best.population) ? current : best);
          } else {
            mainPlanet = this.planets[0];
          }
        }
        if (mainPlanet) mainPlanet.isMainworld = true;

        this.planets.sort((a,b) => a.orbit - b.orbit);
        for (let i = 0; i < this.planets.length; i++) {
          this.planets[i].index = i + 1;
        }
      }

      generateStarsTable() {
        let html = `<table>
          <thead>
            <tr>
              <th>Nome</th>
              <th>Rolagem</th>
              <th>Tipo+Subtipo</th>
              <th>Classe</th>
              <th>Massa (M☉)</th>
              <th>Temp (K)</th>
              <th>Diâmetro</th>
              <th>Luminosidade</th>
              <th>Jump Limit</th>
              <th>Vida (Gyr)</th>
              <th>Cor</th>
              <th>Zona Habitável</th>
            </tr>
          </thead>
          <tbody>`;
        html += this.primaryStar.toTableRow();
        this.secondaryStars.forEach(st => {
          html += st.toTableRow();
        });
        html += "</tbody></table>";
        return html;
      }

      generatePlanetsTable() {
        let html = `<table>
          <thead>
            <tr>
              <th>Índice</th>
              <th>Órbita (UA)</th>
              <th>Luas</th>
              <th>Tipo</th>
              <th>Massa (M⊕)</th>
              <th>Gravidade (g)</th>
              <th>Dia (h)</th>
              <th>Axial Tilt (°)</th>
              <th>Período Orbital (dias)</th>
              <th>População</th>
              <th>Governo</th>
              <th>Nível de Lei</th>
              <th>Tech Level</th>
              <th>UWP</th>
              <th>Cultura</th>
              <th>Economia</th>
              <th>Bioma</th>
            </tr>
          </thead>
          <tbody>`;
        this.planets.forEach(pl => {
          html += pl.toTableRow();
        });
        html += "</tbody></table>";
        return html;
      }

      toHTML() {
        return `
          <div class="system">
            <h2>Sistema #${this.index}</h2>
            <h3>Estrelas</h3>
            ${this.generateStarsTable()}
            <h3>Planetas e Planetoid Belts</h3>
            ${this.generatePlanetsTable()}
          </div>
        `;
      }
    }

    function generateUniverse(numSystems) {
      let arr = [];
      for (let i = 1; i <= numSystems; i++) {
        arr.push(new SolarSystem(i));
      }
      return arr;
    }

    function generateAndDisplay() {
      let num = parseInt(document.getElementById("numSystems").value) || 1;
      let systems = generateUniverse(num);
      let outputDiv = document.getElementById("output");
      outputDiv.innerHTML = "";
      systems.forEach(sys => {
        outputDiv.innerHTML += sys.toHTML();
      });
    }
  </script>
</body>
</html>
