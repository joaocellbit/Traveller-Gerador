<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <title>Geração de Sistemas – Estrelas, Planetas, Belts e Visualização (Regras Oficiais + Estações)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      margin: 20px;
    }
    h1, h2, h3 {
      color: #333;
    }
    table {
      border-collapse: collapse;
      margin-bottom: 20px;
      width: 100%;
      background: #fff;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th, td {
      padding: 5px;
      text-align: center;
    }
    th {
      background: #ddd;
    }
    .system {
      margin-bottom: 40px;
      padding: 10px;
      background: #e8e8e8;
      border: 1px solid #ccc;
    }
    input, button {
      padding: 5px;
      margin: 5px;
    }
    .mainworld {
      background-color: #ccffcc;
    }
    /* Para o SVG */
    .solar-system-svg {
      border: 1px solid #ccc;
      background: #000; /* fundo preto para simular espaço */
      margin-bottom: 20px;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Geração de Sistemas – Estrelas, Planetas, Belts e Visualização (Regras Oficiais + Estações)</h1>
  <p>
    Este código gera sistemas com informações de estrelas, planetas e belts, seguindo as regras oficiais para órbitas (MAO=0.61, baseline=3.1) 
    e agora inclui um cálculo de variação sazonal e latitudinal de temperatura baseado em sin/cos da inclinação axial, conforme descrito no 
    World Builder’s Handbook.
  </p>
  <label for="numSystems">Número de sistemas:</label>
  <input type="number" id="numSystems" value="1" min="1">
  <button onclick="generateAndDisplay()">Gerar</button>

  <div id="output"></div>

  <script>
    // ----------------------------------------------------
    // FUNÇÕES AUXILIARES
    // ----------------------------------------------------
    function rollDice(n, faces) {
      let total = 0;
      for (let i = 0; i < n; i++) {
        total += Math.floor(Math.random() * faces) + 1;
      }
      return total;
    }

    function atmosphereToBar(atmo) {
      if (atmo <= 0) return 0.01;
      if (atmo >= 10) return 10;
      return atmo * 0.2;
    }

    function determineAlbedo(planet) {
      let baseAlbedo = 0.3;
      if (planet.planetType === "Gas Giant") {
        baseAlbedo = 0.3 + ((rollDice(1,6) - 3) * 0.05);
        if (baseAlbedo < 0.2) baseAlbedo = 0.2;
        if (baseAlbedo > 0.5) baseAlbedo = 0.5;
      } else if (planet.biome === "Deserto" || planet.biome === "Árido") {
        baseAlbedo = 0.2 + ((rollDice(1,6) - 3) * 0.02);
      } else if (planet.biome === "Oceânico" || planet.biome === "Tundra") {
        baseAlbedo = 0.3 + ((rollDice(1,6) - 3) * 0.03);
      } else if (planet.biome === "Temperado" || planet.biome === "Tropical") {
        baseAlbedo = 0.3 + ((rollDice(1,6) - 3) * 0.02);
      } else if (planet.planetType === "Planetoid Belt") {
        baseAlbedo = 0.2 + ((rollDice(1,6) - 3) * 0.03);
        if (baseAlbedo < 0.1) baseAlbedo = 0.1;
        if (baseAlbedo > 0.3) baseAlbedo = 0.3;
      }
      let adjust = rollDice(1,6) - 1;
      baseAlbedo -= (0.02 * adjust);
      if (baseAlbedo < 0.05) baseAlbedo = 0.05;
      if (baseAlbedo > 0.95) baseAlbedo = 0.95;
      return parseFloat(baseAlbedo.toFixed(2));
    }

    function determineGreenhouse(planet) {
      let bar = atmosphereToBar(planet.atmosphere);
      let gh = 0.5 * Math.sqrt(bar);
      if ((planet.atmosphere >= 1 && planet.atmosphere <= 9) || planet.atmosphere === 13 || planet.atmosphere === 14) {
        let extra = 0;
        for (let i = 0; i < 3; i++) {
          extra += (rollDice(1,6) * 0.01);
        }
        gh += extra;
      }
      if ([11,12,16,17].includes(planet.atmosphere)) {
        let extra2 = rollDice(1,6) - 1;
        if (extra2 < 0) extra2 = 0;
        gh += extra2;
        if (gh < 0.5) gh = 0.5;
      }
      return parseFloat(gh.toFixed(2));
    }

    // ----------------------------------------------------
    // 1) Temperatura base (sem efeito estufa)
    // ----------------------------------------------------
    function computeBaseTemperature(planet, starLuminosity) {
      if (planet.planetType === "Planetoid Belt" || starLuminosity <= 0) return "N/A";
      let albedo = determineAlbedo(planet);
      let factor = (starLuminosity * (1 - albedo)) / Math.pow(planet.orbit, 2);
      let T_base = 279 * Math.pow(factor, 0.25);
      return T_base.toFixed(1);
    }

    // ----------------------------------------------------
    // 2) Temperatura final (com efeito estufa)
    // ----------------------------------------------------
    function computeMeanTemperature(planet, starLuminosity) {
      if (planet.planetType === "Planetoid Belt" || starLuminosity <= 0) return "N/A";
      let albedo = determineAlbedo(planet);
      let greenhouse = determineGreenhouse(planet);
      let factor = (starLuminosity * (1 - albedo) * (1 + greenhouse)) / Math.pow(planet.orbit, 2);
      let temp = 279 * Math.pow(factor, 0.25);
      return temp.toFixed(1);
    }

    // ----------------------------------------------------
    // 3) Regras Oficiais p/ estações: sin(axial tilt), cos(fração do ano)
    // ----------------------------------------------------
    // Exemplo: dayOfYear=0 => equinócio. Se quisermos ver "verão", usar dayOfYear= localYearDays/4, etc.
    function computeSeasonalVariationsOfficial(planet, meanTemp, dayOfYear=0) {
      if (meanTemp === "N/A") {
        return {
          eqSummer: "N/A", eqWinter: "N/A",
          poleSummer: "N/A", poleWinter: "N/A"
        };
      }
      let tiltDeg = planet.axialTilt; 
      let tiltRad = tiltDeg * (Math.PI / 180); 
      // Basic Axial Tilt Factor = sin(axialTilt)
      let basicTiltFactor = Math.sin(tiltRad);

      // Fração do ano decorrido (0..1)
      let localYearDays = planet.orbitalPeriod || 365; 
      let fractionOfYear = dayOfYear / localYearDays; 
      // Converte fração em ângulo p/ cos()
      let angleDeg = fractionOfYear * 360;
      let angleRad = angleDeg * (Math.PI / 180);

      // Seasonal Axial Tilt Factor
      let seasonalAxialTiltFactor = Math.cos(angleRad) * basicTiltFactor;

      // Convertemos esse fator em amplitude de temperatura
      // Ex.: se tilt=90°, basicTiltFactor=1 => amplitude ±20 K (ajuste a gosto)
      let maxAmplitude = 20; 
      let offset = seasonalAxialTiltFactor * maxAmplitude; 

      // Aplica menor variação no Equador, maior nos polos
      // (você pode usar cos(latitude) ou outra equação do livro)
      let baseMean = parseFloat(meanTemp);

      // Ex.: Equador sofre ~ metade da amplitude
      let eqSummer = (baseMean + offset * 0.5).toFixed(1);
      let eqWinter = (baseMean - offset * 0.5).toFixed(1);

      // Polos podem sofrer ~ amplitude total
      let poleSummer = (baseMean + offset).toFixed(1);
      let poleWinter = (baseMean - offset).toFixed(1);

      return {
        eqSummer, eqWinter, poleSummer, poleWinter
      };
    }

    function calcHabZone(lum) {
      if (lum <= 0) return "N/A";
      let innerHZ = Math.sqrt(lum / 1.51);
      let outerHZ = Math.sqrt(lum / 0.54);
      return `${innerHZ.toFixed(2)} - ${outerHZ.toFixed(2)} AU`;
    }

    // ----------------------------------------------------
    // GERAÇÃO DE ÓRBITAS (regras oficiais)
    // ----------------------------------------------------
    function generateOrbitSlots() {
      let numSlots = rollDice(1,6) + 2; // 3..8
      let slots = [];
      let MAO = 0.61;
      let baseline = 3.1;
      let spread = (baseline - MAO) / (numSlots - 1);
      for (let i = 0; i < numSlots; i++) {
        let orbitDistance = MAO + i * spread;
        slots.push(new OrbitSlot(i+1, orbitDistance));
      }
      return slots;
    }

    class OrbitSlot {
      constructor(index, distanceAU) {
        this.index = index;
        this.distanceAU = distanceAU;
        this.planetType = null;
      }
    }

    function generateAxialTilt() {
      let roll = rollDice(2,6);
      let tilt = 0;
      if (roll >= 2 && roll <= 4) {
        let oneDie = rollDice(1,6);
        tilt = (oneDie - 1) / 50;
      } else if (roll === 5) {
        let oneDie = rollDice(1,6);
        tilt = oneDie / 5;
      } else if (roll === 6) {
        tilt = rollDice(1,6);
      } else if (roll === 7) {
        tilt = 6 + rollDice(1,6);
      } else if (roll === 8 || roll === 9) {
        tilt = 5 + rollDice(1,6) * 5;
      } else {
        let extremeRoll = rollDice(1,6);
        if (extremeRoll <= 2) {
          tilt = 10 + rollDice(1,6) * 10;
        } else if (extremeRoll === 3) {
          tilt = 30 + rollDice(1,6) * 10;
        } else if (extremeRoll === 4) {
          tilt = 90 + rollDice(1,6);
        } else if (extremeRoll === 5) {
          tilt = 180 - rollDice(1,6);
        } else {
          tilt = 120 + rollDice(1,6) * 10;
        }
      }
      return tilt;
    }

    function toHex(value) {
      const hexDigits = "0123456789ABCDEF";
      if (value < 0) value = 0;
      if (value > 15) value = 15;
      return hexDigits[value];
    }

    // ----------------------------------------------------
    // ESTRELAS
    // ----------------------------------------------------
    function determineSubtype(starType, isPrimary) {
      const validTypes = ["O","B","A","F","G","K","M"];
      if (!validTypes.includes(starType)) return "";
      const mappingNumeric = {2:0,3:1,4:3,5:5,6:7,7:9,8:8,9:6,10:4,11:2,12:0};
      const mappingMTypePrimary = {2:8,3:6,4:5,5:4,6:0,7:2,8:1,9:3,10:5,11:7,12:9};
      let r = rollDice(2,6);
      if (starType === "M" && isPrimary) {
        return mappingMTypePrimary[r] ?? 0;
      } else {
        return mappingNumeric[r] ?? 0;
      }
    }

    function determinePrimaryStarTypeDM() {
      return 0;
    }

    function getTypeColumnResult(rollValue) {
      if (rollValue <= 2) return "Special";
      else if (rollValue === 3) return "M";
      else if (rollValue === 4) return "M";
      else if (rollValue === 5) return "M";
      else if (rollValue === 6) return "M";
      else if (rollValue === 7) return "K";
      else if (rollValue === 8) return "K";
      else if (rollValue === 9) return "G";
      else if (rollValue === 10) return "G";
      else if (rollValue === 11) return "F";
      else return "Hot";
    }

    function getHotColumn() {
      let r = rollDice(2,6);
      if (r <= 4) return "A";
      else if (r <= 9) return "B";
      else return "O";
    }

    function getSpecialColumn() {
      let r = rollDice(2,6);
      if (r <= 3) return "Class VI";
      else if (r <= 5) return "BD";
      else if (r <= 7) return "D";
      else return "Class VI";
    }

    class Star {
      constructor(nome="Primária") {
        this.nome = nome;
        this.isPrimary = (nome === "Primária");
        this.initialRoll = rollDice(2,6) + determinePrimaryStarTypeDM();
        if (this.initialRoll < 2) this.initialRoll = 2;
        if (this.initialRoll > 12) this.initialRoll = 12;
        let typeResult = getTypeColumnResult(this.initialRoll);
        this.finalType = null;
        this.luminosityClass = "V";
        this.specialCategory = "";
        this.subtype = "";

        if (typeResult === "Special") {
          let specialRes = getSpecialColumn();
          if (specialRes === "BD") {
            this.finalType = "Brown Dwarf";
            this.luminosityClass = "—";
            this.specialCategory = "Brown Dwarf";
          } else if (specialRes === "D") {
            this.finalType = "White Dwarf";
            this.luminosityClass = "D";
            this.specialCategory = "Post-Stellar";
          } else if (specialRes === "Class VI") {
            this.finalType = "K";
            this.luminosityClass = "VI";
          } else {
            this.finalType = "M";
            this.luminosityClass = "VI";
          }
        }
        else if (typeResult === "Hot") {
          let hotRes = getHotColumn();
          this.finalType = hotRes;
          this.luminosityClass = "V";
        }
        else if (["M","K","G","F"].includes(typeResult)) {
          this.finalType = typeResult;
          this.luminosityClass = "V";
        }
        else {
          this.finalType = "M";
        }

        const exoticTypes = ["Brown Dwarf","White Dwarf","Black Hole","Neutron Star","Pulsar","Anomaly"];
        if (!exoticTypes.includes(this.finalType)) {
          this.subtype = determineSubtype(this.finalType, this.isPrimary);
        }

        let mainSequenceProps = {
          'O': { mass: 90, temperature: 50000, diameter: 20 },
          'B': { mass: 18, temperature: 30000, diameter: 7 },
          'A': { mass: 2.2, temperature: 10000, diameter: 2.2 },
          'F': { mass: 1.5, temperature: 7500, diameter: 1.7 },
          'G': { mass: 1.1, temperature: 6000, diameter: 1.1 },
          'K': { mass: 0.8, temperature: 5200, diameter: 0.8 },
          'M': { mass: 0.5, temperature: 3700, diameter: 0.5 }
        };
        let giantProps = {
          'O': { mass: 60, temperature: 30000, diameter: 40 },
          'B': { mass: 25, temperature: 15000, diameter: 20 },
          'A': { mass: 10, temperature: 10000, diameter: 10 },
          'F': { mass: 4, temperature: 7000, diameter: 6 },
          'G': { mass: 2.4, temperature: 5500, diameter: 15 },
          'K': { mass: 1.5, temperature: 4500, diameter: 30 },
          'M': { mass: 0.7, temperature: 3500, diameter: 60 }
        };
        let brownDwarfProps = { mass: 0.07, temperature: 1000, diameter: 0.15 };
        let whiteDwarfProps = { mass: 0.6, temperature: 100000, diameter: 0.01 };

        let chosenProps = null;
        if (this.specialCategory === "Brown Dwarf") {
          chosenProps = brownDwarfProps;
        } else if (this.luminosityClass === "D") {
          chosenProps = whiteDwarfProps;
        } else if (["III","II","Ib","Ia","VI"].includes(this.luminosityClass)) {
          chosenProps = giantProps[this.finalType] || giantProps["M"];
        } else {
          chosenProps = mainSequenceProps[this.finalType] || mainSequenceProps["M"];
        }

        this.spectralType = this.finalType;
        this.mass = chosenProps.mass;
        this.temperature = chosenProps.temperature;
        this.diameter = chosenProps.diameter;
        this.luminosity = parseFloat((Math.pow(this.diameter, 2) * Math.pow(this.temperature / 5772, 4)).toFixed(3));
        this.jumpLimit = parseFloat((0.93 * this.mass).toFixed(2));
        this.lifetime = parseFloat((10 * Math.pow(this.mass, -2.5)).toFixed(2));

        const colorMapping = {
          'O': "Azul",
          'B': "Azul-Branco",
          'A': "Branco",
          'F': "Amarelo-Branco",
          'G': "Amarelo",
          'K': "Laranja",
          'M': "Vermelho",
          'Brown Dwarf': "Marrom-escuro",
          'White Dwarf': "Branco-azulado"
        };
        this.color = colorMapping[this.finalType] || "Desconhecido";
      }

      getHabZone() {
        if (this.luminosity <= 0) return "N/A";
        return calcHabZone(this.luminosity);
      }

      toTableRow() {
        let typePlusSubtype = this.spectralType;
        if (this.subtype !== "") {
          typePlusSubtype += this.subtype;
        }
        return `<tr>
          <td>${this.nome}</td>
          <td>${this.initialRoll}</td>
          <td>${typePlusSubtype}</td>
          <td>${this.luminosityClass}</td>
          <td>${this.mass.toFixed(3)}</td>
          <td>${this.temperature}</td>
          <td>${this.diameter.toFixed(3)}</td>
          <td>${this.luminosity}</td>
          <td>${this.jumpLimit}</td>
          <td>${this.lifetime}</td>
          <td>${this.color}</td>
          <td>${this.getHabZone()}</td>
        </tr>`;
      }
    }

    // ----------------------------------------------------
    // PLANETAS E BELTS
    // ----------------------------------------------------
    function checkGasGiantExistenceAndQuantity(star, starCount) {
      let rollExist = rollDice(2,6);
      if (rollExist < 2) return 0;
      let quantityDM = 0;
      if (star.luminosityClass === "V" && starCount === 1) {
        quantityDM += 1;
      }
      let rollQty = rollDice(2,6) + quantityDM;
      if (rollQty <= 2) return 1;
      if (rollQty <= 4) return 1;
      if (rollQty <= 6) return 2;
      if (rollQty <= 8) return 3;
      if (rollQty <= 11) return 4;
      if (rollQty === 12) return 5;
      return 6;
    }

    class Planet {
      constructor(index, planetType, orbitAU) {
        this.index = index;
        this.orbit = orbitAU;
        this.planetType = planetType;
        this.numMoons = Math.floor(Math.random() * 6);
        this.isMainworld = false;

        if (planetType === "Gas Giant") {
          this.size = Math.floor(Math.random() * 3) + 8;
          this.atmosphere = 0;
          this.hydrographics = 0;
          this.gravity = parseFloat((Math.random() * 2 + 1).toFixed(2));
          this.temperature = Math.floor(Math.random() * 151) + 50;
          this.mass = parseFloat((Math.random() * 200 + 100).toFixed(2));
        } else if (planetType === "Planetoid Belt") {
          this.size = 0;
          this.atmosphere = 0;
          this.hydrographics = 0;
          this.gravity = 0;
          this.temperature = 0;
          this.mass = 0;
        } else {
          this.size = Math.floor(Math.random() * 11);
          this.atmosphere = Math.floor(Math.random() * 16);
          this.hydrographics = Math.floor(Math.random() * 11);
          this.gravity = parseFloat(
            (1 + (this.size - 5) * 0.1 + (Math.random() * 0.4 - 0.2)).toFixed(2)
          );
          this.temperature = Math.floor(Math.random() * 251) + 100;
          this.mass = parseFloat(
            (Math.random() * (10 - 0.1) + 0.1).toFixed(2)
          );
        }

        this.dayLength = parseFloat((Math.random() * (72 - 10) + 10).toFixed(2));
        this.axialTilt = generateAxialTilt();
        this.orbitalPeriod = 0;

        if (planetType === "Terrestrial (Inhabited)") {
          this.population = Math.floor(Math.random() * 13);
          if (this.population === 0) this.population = 1;
          this.government = Math.floor(Math.random() * 11);
          this.lawLevel = Math.floor(Math.random() * 11);
          this.techLevel = Math.floor(Math.random() * 16);
          this.starport = ['A','B','C','D','E','X'][Math.floor(Math.random()*6)];
          this.culture = ['Tradicional','Progressista','Militarista','Comercial'][Math.floor(Math.random()*4)];
          this.economy = ['Agrícola','Industrial','Tecnológica','Mineradora'][Math.floor(Math.random()*4)];
        } else {
          this.population = 0;
          this.government = 0;
          this.lawLevel = 0;
          this.techLevel = 0;
          this.starport = "X";
          this.culture = "N/A";
          this.economy = "N/A";
        }

        if (planetType === "Gas Giant" || planetType === "Planetoid Belt") {
          this.biome = planetType;
        } else {
          if (this.atmosphere < 3) {
            this.biome = this.hydrographics < 3 ? "Deserto" : "Árido";
          } else if (this.atmosphere <= 7) {
            this.biome = this.hydrographics > 7 ? "Oceânico" : "Temperado";
          } else {
            this.biome = this.hydrographics < 4 ? "Tundra" : "Tropical";
          }
        }
      }

      generateUWP() {
        if (this.planetType === "Gas Giant" || this.planetType === "Planetoid Belt") {
          return this.planetType;
        } else if (this.planetType === "Terrestrial (Barren)") {
          return "Barren";
        } else if (this.planetType === "Terrestrial (Inhabited)") {
          return (
            this.starport +
            toHex(this.size) +
            toHex(this.atmosphere) +
            toHex(this.hydrographics) +
            toHex(this.population) +
            toHex(this.government) +
            toHex(this.lawLevel) +
            "-" +
            this.techLevel.toString().padStart(2, "0")
          );
        } else {
          return "Desconhecido";
        }
      }

      toTableRow(starLuminosity) {
        let rowClass = this.isMainworld ? "mainworld" : "";

        // 1) Temperatura base, greenhouse e média
        let baseTemp = computeBaseTemperature(this, starLuminosity);
        let meanTemp = computeMeanTemperature(this, starLuminosity);
        let greenhouseDelta = "N/A";
        if (meanTemp !== "N/A" && baseTemp !== "N/A") {
          greenhouseDelta = (parseFloat(meanTemp) - parseFloat(baseTemp)).toFixed(1);
        }

        // 2) Escolhemos um dayOfYear (por exemplo 0 => equinócio)
        // Se quiser ver "pico do verão", pode ser dayOfYear= orbitalPeriod/4
        let dayOfYear = 0; 
        let seasonal = computeSeasonalVariationsOfficial(this, meanTemp, dayOfYear);

        return `
          <tr class="${rowClass}">
            <td>${this.index}</td>
            <td>${this.orbit.toFixed(2)}</td>
            <td>${this.numMoons}</td>
            <td>${this.planetType}</td>
            <td>${this.mass}</td>
            <td>${this.gravity}</td>
            <td>${this.dayLength}</td>
            <td>${this.axialTilt.toFixed(2)}</td>
            <td>${this.orbitalPeriod}</td>
            <td>${this.population}</td>
            <td>${this.government}</td>
            <td>${this.lawLevel}</td>
            <td>${this.techLevel}</td>
            <td>${this.generateUWP()}</td>
            <td>${this.culture}</td>
            <td>${this.economy}</td>
            <td>${this.biome}</td>
            <td>
              <!-- Temperatura Base / Greenhouse / Média -->
              <table style="width:100%; border:none;">
                <tr>
                  <th style="border:none; padding:2px;">Base</th>
                  <th style="border:none; padding:2px;">Greenhouse</th>
                  <th style="border:none; padding:2px;">Média</th>
                </tr>
                <tr>
                  <td style="border:none; padding:2px;">${baseTemp}</td>
                  <td style="border:none; padding:2px;">${greenhouseDelta}</td>
                  <td style="border:none; padding:2px;">${meanTemp}</td>
                </tr>
              </table>
              <br>
              <!-- Estaçoes: equador e polos (diaOfYear=0) -->
              <table style="width:100%; border:none;">
                <tr>
                  <th colspan="2" style="border:none;">Equador</th>
                  <th colspan="2" style="border:none;">Polo</th>
                </tr>
                <tr>
                  <th style="border:none;">Verão</th>
                  <th style="border:none;">Inverno</th>
                  <th style="border:none;">Verão</th>
                  <th style="border:none;">Inverno</th>
                </tr>
                <tr>
                  <td style="border:none;">${seasonal.eqSummer}</td>
                  <td style="border:none;">${seasonal.eqWinter}</td>
                  <td style="border:none;">${seasonal.poleSummer}</td>
                  <td style="border:none;">${seasonal.poleWinter}</td>
                </tr>
              </table>
            </td>
          </tr>
        `;
      }
    }

    function generatePlanetoidBelts(system) {
      let rollForBelt = rollDice(2,6);
      if (rollForBelt < 8) return [];
      let DM = 0;
      let gasGiantCount = system.planets.filter(p => p.planetType === "Gas Giant").length;
      if (gasGiantCount > 0) DM += 1;
      if (system.secondaryStars.length >= 1) DM += 1;
      let beltRoll = rollDice(2,6) + DM;
      let beltCount;
      if (beltRoll <= 6) beltCount = 1;
      else if (beltRoll <= 11) beltCount = 2;
      else beltCount = 3;
      let belts = [];
      let maxOrbit = Math.max(...system.orbitSlots.map(s => s.distanceAU));
      for (let i = 0; i < beltCount; i++) {
        let belt = new Planet(system.planets.length + 1, "Planetoid Belt", 0);
        belt.orbit = maxOrbit + (i + 1) * (Math.random() * 0.5 + 0.5);
        belts.push(belt);
      }
      return belts;
    }

    // ----------------------------------------------------
    // FUNÇÃO QUE CRIA O SVG INTERATIVO (igual)
    // ----------------------------------------------------
    function createSystemSVG(solarSystem) {
      let width = 600, height = 600;
      let centerX = width / 2, centerY = height / 2;
      let maxOrbit = 0;
      solarSystem.planets.forEach(p => {
        if (p.orbit > maxOrbit) maxOrbit = p.orbit;
      });
      if (maxOrbit < 0.1) maxOrbit = 0.1;
      let maxRadius = 250;
      let scale = maxRadius / maxOrbit;
      let svg = `<svg class="solar-system-svg" width="${width}" height="${height}">`;
      let starColor = solarSystem.primaryStar.color.toLowerCase();
      let starRadius = 10;
      svg += `
        <circle cx="${centerX}" cy="${centerY}" r="${starRadius}" fill="${mapColor(starColor)}">
          <title>${solarSystem.primaryStar.nome} (${solarSystem.primaryStar.finalType})</title>
        </circle>
      `;
      let offset = 20;
      solarSystem.secondaryStars.forEach((sec, idx) => {
        let secColor = sec.color.toLowerCase();
        svg += `
          <circle cx="${centerX + (offset * (idx + 1))}" cy="${centerY}" r="8" fill="${mapColor(secColor)}">
            <title>${sec.nome} (${sec.finalType})</title>
          </circle>
        `;
      });
      solarSystem.planets.forEach(planet => {
        let rOrbit = planet.orbit * scale;
        let orbitColor = "#555";
        svg += `
          <circle cx="${centerX}" cy="${centerY}" r="${rOrbit}" fill="none" stroke="${orbitColor}" stroke-width="1" opacity="0.5"></circle>
        `;
        let angle = Math.random() * 2 * Math.PI;
        let px = centerX + rOrbit * Math.cos(angle);
        let py = centerY + rOrbit * Math.sin(angle);
        let planetRadius = 4;
        if (planet.planetType === "Gas Giant") {
          planetRadius = 6;
        } else if (planet.planetType === "Planetoid Belt") {
          planetRadius = 2;
        } else if (planet.isMainworld) {
          planetRadius = 5;
        }
        let planetColor = "#f00";
        if (planet.planetType === "Gas Giant") {
          planetColor = "#00f";
        } else if (planet.planetType === "Planetoid Belt") {
          planetColor = "#999";
        } else if (planet.isMainworld) {
          planetColor = "#0f0";
        }
        svg += `
          <circle cx="${px}" cy="${py}" r="${planetRadius}" fill="${planetColor}">
            <title>
              ${planet.planetType} (Órbita: ${planet.orbit.toFixed(2)} UA)
              UWP: ${planet.generateUWP()}
            </title>
          </circle>
        `;
      });
      svg += `</svg>`;
      return svg;
    }

    function mapColor(colorName) {
      switch(colorName) {
        case "azul": return "#00f";
        case "azul-branco": return "#aaf";
        case "branco": return "#fff";
        case "amarelo-branco": return "#ff9";
        case "amarelo": return "#ff0";
        case "laranja": return "orange";
        case "vermelho": return "red";
        case "marrom-escuro": return "#663300";
        case "branco-azulado": return "#ccf";
        default: return "#fff";
      }
    }

    // ----------------------------------------------------
    // CLASSE SOLARSYSTEM
    // ----------------------------------------------------
    class SolarSystem {
      constructor(index) {
        this.index = index;
        this.primaryStar = new Star("Primária");
        this.secondaryStars = [];
        if (Math.random() < 0.3) {
          this.secondaryStars.push(new Star("Secundária"));
        }
        let starCount = 1 + this.secondaryStars.length;
        let ggCount = checkGasGiantExistenceAndQuantity(this.primaryStar, starCount);

        // Gera órbitas (regras oficiais)
        this.orbitSlots = generateOrbitSlots();

        // Define Gas Giants
        if (ggCount > 0) {
          let shuffled = [...this.orbitSlots].sort(() => Math.random() - 0.5);
          let ggSlots = shuffled.slice(0, ggCount);
          ggSlots.forEach(s => s.planetType = "Gas Giant");
        }

        this.planets = [];
        let planetIndex = 1;
        for (let slot of this.orbitSlots) {
          if (slot.planetType === "Gas Giant") {
            let pl = new Planet(planetIndex, "Gas Giant", slot.distanceAU);
            this.planets.push(pl);
            planetIndex++;
          } else {
            if (rollDice(1,6) >= 4) {
              let r = Math.floor(Math.random()*100)+1;
              let pType = (r <= 60) ? "Terrestrial (Barren)" : "Terrestrial (Inhabited)";
              let pl = new Planet(planetIndex, pType, slot.distanceAU);
              this.planets.push(pl);
              planetIndex++;
            }
          }
        }

        // Gera belts
        let belts = generatePlanetoidBelts(this);
        belts.forEach(b => this.planets.push(b));

        // Período orbital
        this.planets.forEach(p => {
          let periodYears = Math.sqrt(Math.pow(p.orbit,3) / this.primaryStar.mass);
          p.orbitalPeriod = Math.round(periodYears * 365.25);
        });

        // Identifica mainworld
        let L = this.primaryStar.luminosity;
        let innerHZ = Math.sqrt(L / 1.51);
        let outerHZ = Math.sqrt(L / 0.54);
        let candidates = this.planets.filter(pp => pp.planetType === "Terrestrial (Inhabited)" && pp.orbit >= innerHZ && pp.orbit <= outerHZ);
        let mainPlanet = null;
        if (candidates.length > 0) {
          mainPlanet = candidates.reduce((best, current) => (current.population > best.population) ? current : best);
        } else {
          let terrestrial = this.planets.filter(pp => pp.planetType.startsWith("Terrestrial"));
          if (terrestrial.length > 0) {
            mainPlanet = terrestrial.reduce((best, current) => (current.population > best.population) ? current : best);
          } else {
            mainPlanet = this.planets[0];
          }
        }
        if (mainPlanet) {
          mainPlanet.isMainworld = true;
        }

        // Ordena
        this.planets.sort((a,b) => a.orbit - b.orbit);
        for (let i=0; i<this.planets.length; i++) {
          this.planets[i].index = i+1;
        }
      }

      generateStarsTable() {
        let html = `<table>
          <thead>
            <tr>
              <th>Nome</th>
              <th>Rolagem</th>
              <th>Tipo+Subtipo</th>
              <th>Classe</th>
              <th>Massa (M☉)</th>
              <th>Temp (K)</th>
              <th>Diâmetro</th>
              <th>Luminosidade</th>
              <th>Jump Limit</th>
              <th>Vida (Gyr)</th>
              <th>Cor</th>
              <th>Zona Habitável</th>
            </tr>
          </thead>
          <tbody>`;
        html += this.primaryStar.toTableRow();
        this.secondaryStars.forEach(st => {
          html += st.toTableRow();
        });
        html += "</tbody></table>";
        return html;
      }

      generatePlanetsTable() {
        let html = `<table>
          <thead>
            <tr>
              <th>Índice</th>
              <th>Órbita (UA)</th>
              <th>Luas</th>
              <th>Tipo</th>
              <th>Massa (M⊕)</th>
              <th>Gravidade (g)</th>
              <th>Dia (h)</th>
              <th>Axial Tilt (°)</th>
              <th>Período Orbital (dias)</th>
              <th>População</th>
              <th>Governo</th>
              <th>Nível de Lei</th>
              <th>Tech Level</th>
              <th>UWP</th>
              <th>Cultura</th>
              <th>Economia</th>
              <th>Bioma</th>
              <th>Temperaturas</th>
            </tr>
          </thead>
          <tbody>`;
        this.planets.forEach(pl => {
          html += pl.toTableRow(this.primaryStar.luminosity);
        });
        html += "</tbody></table>";
        return html;
      }

      generateSystemDiagram() {
        return createSystemSVG(this);
      }

      toHTML() {
        return `
          <div class="system">
            <h2>Sistema #${this.index}</h2>
            <h3>Estrelas</h3>
            ${this.generateStarsTable()}
            <h3>Planetas e Planetoid Belts</h3>
            ${this.generatePlanetsTable()}
            <h3>Visualização do Sistema</h3>
            ${this.generateSystemDiagram()}
          </div>
        `;
      }
    }

    function generateUniverse(numSystems) {
      let arr = [];
      for (let i = 1; i <= numSystems; i++) {
        arr.push(new SolarSystem(i));
      }
      return arr;
    }

    function generateAndDisplay() {
      let num = parseInt(document.getElementById("numSystems").value) || 1;
      let systems = generateUniverse(num);
      let outputDiv = document.getElementById("output");
      outputDiv.innerHTML = "";
      systems.forEach(sys => {
        outputDiv.innerHTML += sys.toHTML();
      });
    }
  </script>
</body>
</html>
